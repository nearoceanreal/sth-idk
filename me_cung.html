<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√≤ Ch∆°i M√™ Cung</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* NgƒÉn cu·ªôn/thu ph√≥ng m·∫∑c ƒë·ªãnh c·ªßa tr√¨nh duy·ªát */
            -webkit-user-select: none; /* NgƒÉn ch·ªçn vƒÉn b·∫£n tr√™n Safari */
            -moz-user-select: none; /* NgƒÉn ch·ªçn vƒÉn b·∫£n tr√™n Firefox */
            -ms-user-select: none; /* NgƒÉn ch·ªçn vƒÉn b·∫£n tr√™n IE/Edge */
            user-select: none; /* NgƒÉn ch·ªçn vƒÉn b·∫£n theo chu·∫©n */
            overscroll-behavior: none; /* NgƒÉn cu·ªôn qu√° m·ª©c */
            /* Cho ph√©p cu·ªôn d·ªçc khi n·ªôi dung tr√†n ra */
            overflow-y: auto; 
        }
        canvas {
            background-color: #000000; /* N·ªÅn canvas m√†u ƒëen */
            border: 2px solid #4b5563; /* Vi·ªÅn m√†u x√°m ƒë·∫≠m */
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3); /* ƒê·ªï b√≥ng ƒë·ªè n·ªïi b·∫≠t */
            transition: transform 0.3s ease-in-out; /* Hi·ªáu ·ª©ng chuy·ªÉn ƒë·ªông */
        }
        /* Ki·ªÉu d√°ng cho c√°c n√∫t ƒëi·ªÅu khi·ªÉn c·∫£m ·ª©ng */
        .touch-controls button {
            width: 65px; /* K√≠ch th∆∞·ªõc n√∫t l·ªõn cho d·ªÖ ch·∫°m */
            height: 65px;
            font-size: 28px; /* K√≠ch th∆∞·ªõc ch·ªØ/bi·ªÉu t∆∞·ª£ng l·ªõn h∆°n */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%; /* N√∫t tr√≤n */
            transition: background-color 0.2s, transform 0.1s;
        }
        .touch-controls button:active {
            transform: scale(0.95); /* Hi·ªáu ·ª©ng nh·∫•n */
        }
        /* Ki·ªÉu d√°ng ti√™u ƒë·ªÅ */
        #title {
            font-size: 2.5rem; /* K√≠ch th∆∞·ªõc ch·ªØ ƒë√°p ·ª©ng cho ti√™u ƒë·ªÅ */
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        /* ƒêi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc ti√™u ƒë·ªÅ cho m√†n h√¨nh l·ªõn h∆°n */
        @media (min-width: 768px) {
            #title {
                font-size: 3.5rem;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-900 to-black flex flex-col items-center justify-start min-h-screen p-4">

    <div class="text-center mb-6" id="header-section">
        <h1 id="title" class="text-red-500 font-extrabold tracking-wide">TR√í CH∆†I M√ä CUNG</h1>
        <p class="text-gray-300 mt-3 text-lg">S·ª≠ d·ª•ng c√°c ph√≠m m≈©i t√™n (ho·∫∑c c√°c n√∫t b√™n d∆∞·ªõi) ƒë·ªÉ ƒëi ƒë·∫øn l√° c·ªù!</p>
    </div>

    <canvas id="mazeCanvas" class="max-w-full h-auto flex-shrink-0"></canvas>

    <div id="message" class="mt-6 text-3xl font-extrabold text-green-400 h-10 transform transition-transform duration-300 ease-out flex-shrink-0"></div>
    
    <div class="flex flex-row justify-center items-center mt-8 flex-shrink-0" id="button-section">
        <button id="newGameButton" class="px-8 py-4 bg-red-600 text-white text-xl font-bold rounded-full shadow-lg hover:bg-red-700 focus:outline-none focus:ring-4 focus:ring-red-500 focus:ring-opacity-75 transition-all transform hover:scale-110 active:scale-95">
            Ch∆°i L·∫°i
        </button>
        <button id="hintButton" class="ml-4 px-8 py-4 bg-blue-600 text-white text-xl font-bold rounded-full shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-75 transition-all transform hover:scale-110 active:scale-95">
            H∆∞·ªõng D·∫´n
        </button>
    </div>

    <div class="touch-controls mt-8 grid grid-cols-3 gap-3 w-60 md:hidden flex-shrink-0" id="touch-controls-section">
        <div></div>
        <button id="btn-up" class="bg-red-500 text-white rounded-full shadow-md active:bg-red-600">‚Üë</button>
        <div></div>
        <button id="btn-left" class="bg-red-500 text-white rounded-full shadow-md active:bg-red-600">‚Üê</button>
        <button id="btn-down" class="bg-red-500 text-white rounded-full shadow-md active:bg-red-600">‚Üì</button>
        <button id="btn-right" class="bg-red-500 text-white rounded-full shadow-md active:bg-red-600">‚Üí</button>
    </div>

    <script>
        // L·∫•y c√°c ph·∫ßn t·ª≠ HTML
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const messageEl = document.getElementById('message');
        const newGameButton = document.getElementById('newGameButton');
        const hintButton = document.getElementById('hintButton'); 

        // C·∫•u h√¨nh m√™ cung
        const TILE_SIZE = 25; // K√≠ch th∆∞·ªõc c∆° b·∫£n c·ªßa m·ªói √¥
        let MAZE_ROWS; // S·ªë h√†ng c·ªßa m√™ cung
        let MAZE_COLS; // S·ªë c·ªôt c·ªßa m√™ cung
        let maze = [];

        // ƒê·ªãnh nghƒ©a ng∆∞·ªùi ch∆°i v√† m·ª•c ti√™u
        let player = { x: 1, y: 1, color: '#3b82f6', size: TILE_SIZE * 0.6 };
        let goal = {};
        let gameWon = false;
        let showHint = false; 
        let currentHintPath = null; 

        /**
         * H√†m t·∫°o m√™ cung ng·∫´u nhi√™n b·∫±ng thu·∫≠t to√°n Recursive Backtracker (DFS)
         * @param {number} rows - S·ªë h√†ng c·ªßa m√™ cung (ph·∫£i l√† s·ªë l·∫ª)
         * @param {number} cols - S·ªë c·ªôt c·ªßa m√™ cung (ph·∫£i l√† s·ªë l·∫ª)
         */
        function generateMaze(rows, cols) {
            let newMaze = Array(rows).fill(null).map(() => Array(cols).fill(1)); // 1 = t∆∞·ªùng, 0 = ƒë∆∞·ªùng ƒëi
            const stack = [];
            let current = { r: 1, c: 1 };
            newMaze[current.r][current.c] = 0; 
            
            // T√≠nh t·ªïng s·ªë √¥ ƒë∆∞·ªùng ƒëi c·∫ßn thi·∫øt cho thu·∫≠t to√°n t·∫°o m√™ cung
            const totalPathCells = Math.ceil((rows - 1) / 2) * Math.ceil((cols - 1) / 2);
            let visitedCount = 1;

            while (visitedCount < totalPathCells) {
                const { r, c } = current;
                const neighbors = [];

                // Ki·ªÉm tra c√°c √¥ l√¢n c·∫≠n ch∆∞a ƒë∆∞·ª£c thƒÉm (c√°ch 2 b∆∞·ªõc, b·ªè qua t∆∞·ªùng)
                if (r > 1 && newMaze[r - 2][c] === 1) neighbors.push({ r: r - 2, c: c, wall: { r: r - 1, c: c } }); // L√™n
                if (c < cols - 2 && newMaze[r][c + 2] === 1) neighbors.push({ r: r, c: c + 2, wall: { r: r, c: c + 1 } }); // Ph·∫£i
                if (r < rows - 2 && newMaze[r + 2][c] === 1) neighbors.push({ r: r + 2, c: c, wall: { r: r + 1, c: c } }); // Xu·ªëng
                if (c > 1 && newMaze[r][c - 2] === 1) neighbors.push({ r: r, c: c - 2, wall: { r: r, c: c - 1 } }); // Tr√°i

                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    stack.push(current); 
                    newMaze[next.wall.r][next.wall.c] = 0; 
                    current = { r: next.r, c: next.c }; 
                    newMaze[current.r][current.c] = 0; 
                    visitedCount++;
                } else if (stack.length > 0) {
                    current = stack.pop(); 
                } else {
                    break;
                }
            }

            // ƒê·∫£m b·∫£o ƒëi·ªÉm b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c l√† ƒë∆∞·ªùng ƒëi
            newMaze[1][1] = 0; 
            newMaze[rows - 2][cols - 2] = 0; 

            // ƒê·∫£m b·∫£o c√≥ ƒë∆∞·ªùng ƒëi ƒë·∫øn m·ª•c ti√™u n·∫øu n√≥ b·ªã t∆∞·ªùng bao quanh do ng·∫´u nhi√™n
            if (newMaze[rows - 3][cols - 2] === 1) newMaze[rows - 3][cols - 2] = 0;
            if (newMaze[rows - 2][cols - 3] === 1) newMaze[rows - 2][cols - 3] = 0;

            return newMaze;
        }

        /**
         * ƒêi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc m√™ cung d·ª±a tr√™n k√≠ch th∆∞·ªõc m√†n h√¨nh hi·ªán t·∫°i.
         * ƒê·∫£m b·∫£o s·ªë h√†ng v√† c·ªôt l√† s·ªë l·∫ª v√† c√≥ k√≠ch th∆∞·ªõc t·ªëi thi·ªÉu.
         */
        function setMazeDimensions() {
            // L·∫•y chi·ªÅu cao c·ªßa c√°c ph·∫ßn t·ª≠ UI c·ªë ƒë·ªãnh
            const headerHeight = document.getElementById('header-section').offsetHeight;
            const messageHeight = messageEl.offsetHeight + (parseInt(window.getComputedStyle(messageEl).marginTop) || 0);
            const buttonContainerHeight = document.getElementById('button-section').offsetHeight + (parseInt(window.getComputedStyle(document.getElementById('button-section')).marginTop) || 0);
            
            // Ch·ªâ t√≠nh touch controls n·∫øu ch√∫ng hi·ªÉn th·ªã (md:hidden)
            const touchControlsSection = document.getElementById('touch-controls-section');
            const touchControlsHeight = window.getComputedStyle(touchControlsSection).display !== 'none' ? 
                                       (touchControlsSection.offsetHeight + (parseInt(window.getComputedStyle(touchControlsSection).marginTop) || 0)) : 0;
            
            const bodyPaddingY = (parseInt(window.getComputedStyle(document.body).paddingTop) || 0) + (parseInt(window.getComputedStyle(document.body).paddingBottom) || 0);
            
            const totalFixedUIHeight = headerHeight + messageHeight + buttonContainerHeight + touchControlsHeight + bodyPaddingY;

            // Chi·ªÅu cao t·ªëi ƒëa c√≤n l·∫°i cho canvas (tr·ª´ th√™m m·ªôt √≠t buffer)
            const maxCanvasHeight = window.innerHeight - totalFixedUIHeight - 20; 
            const maxCanvasWidth = window.innerWidth * 0.9; // 90% chi·ªÅu r·ªông m√†n h√¨nh

            // T√≠nh to√°n s·ªë c·ªôt v√† h√†ng t·ªëi ƒëa c√≥ th·ªÉ v·ª´a
            MAZE_COLS = Math.floor(maxCanvasWidth / TILE_SIZE);
            MAZE_ROWS = Math.floor(maxCanvasHeight / TILE_SIZE);

            // ƒê·∫£m b·∫£o s·ªë c·ªôt v√† h√†ng l√† s·ªë l·∫ª
            MAZE_COLS = MAZE_COLS % 2 === 0 ? MAZE_COLS - 1 : MAZE_COLS;
            MAZE_ROWS = MAZE_ROWS % 2 === 0 ? MAZE_ROWS - 1 : MAZE_ROWS;

            // ƒê·∫£m b·∫£o k√≠ch th∆∞·ªõc t·ªëi thi·ªÉu ƒë·ªÉ tr√≤ ch∆°i c√≥ th·ªÉ ch∆°i ƒë∆∞·ª£c v√† kh√¥ng b·ªã qu√° nh·ªè
            MAZE_COLS = Math.max(15, MAZE_COLS); 
            MAZE_ROWS = Math.max(15, MAZE_ROWS); 

            // ƒê·∫£m b·∫£o h√†ng v√† c·ªôt √≠t nh·∫•t l√† 3 (1 t∆∞·ªùng, 1 ƒë∆∞·ªùng ƒëi, 1 t∆∞·ªùng)
            MAZE_COLS = MAZE_COLS < 3 ? 3 : MAZE_COLS;
            MAZE_ROWS = MAZE_ROWS < 3 ? 3 : MAZE_ROWS;
            
            // ƒêi·ªÅu ch·ªânh l·∫°i ƒë·ªÉ ƒë·∫£m b·∫£o ch√∫ng l√† s·ªë l·∫ª (ph√≤ng tr∆∞·ªùng h·ª£p min size l√†m ch·∫µn)
            if (MAZE_COLS % 2 === 0) MAZE_COLS--;
            if (MAZE_ROWS % 2 === 0) MAZE_ROWS--;

            // Fallback cho m√†n h√¨nh r·∫•t nh·ªè n·∫øu v·∫´n l√† s·ªë ch·∫µn
            if (MAZE_COLS < 3) MAZE_COLS = 3;
            if (MAZE_ROWS < 3) MAZE_ROWS = 3;

            // ƒê·∫∑t k√≠ch th∆∞·ªõc canvas
            canvas.width = MAZE_COLS * TILE_SIZE;
            canvas.height = MAZE_ROWS * TILE_SIZE;

            // C·∫≠p nh·∫≠t l·∫°i k√≠ch th∆∞·ªõc ng∆∞·ªùi ch∆°i theo TILE_SIZE m·ªõi
            player.size = TILE_SIZE * 0.6;
        }

        // H√†m kh·ªüi t·∫°o v√† v·∫Ω game
        function init() {
            setMazeDimensions(); 
            maze = generateMaze(MAZE_ROWS, MAZE_COLS);
            player.x = 1;
            player.y = 1;
            goal.x = MAZE_COLS - 2;
            goal.y = MAZE_ROWS - 2;
            gameWon = false;
            messageEl.textContent = '';
            canvas.style.transform = 'scale(1)';
            showHint = false; 
            currentHintPath = null; 
            drawGame();
        }

        // H√†m v·∫Ω to√†n b·ªô game
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            drawMaze(); 
            drawGoal(); 
            if (showHint && currentHintPath) { 
                drawHintPath(currentHintPath);
            }
            drawPlayer(); 
        }

        // H√†m v·∫Ω m√™ cung
        function drawMaze() {
            for (let row = 0; row < MAZE_ROWS; row++) {
                for (let col = 0; col < MAZE_COLS; col++) {
                    if (maze[row][col] === 1) {
                        ctx.fillStyle = '#dc2626'; /* M√†u t∆∞·ªùng ƒë·ªè */
                        ctx.fillRect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        }

        // H√†m v·∫Ω ng∆∞·ªùi ch∆°i
        function drawPlayer() {
            const playerX = player.x * TILE_SIZE + TILE_SIZE / 2;
            const playerY = player.y * TILE_SIZE + TILE_SIZE / 2;
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(playerX, playerY, player.size / 2, 0, 2 * Math.PI);
            ctx.fill();
        }

        // H√†m v·∫Ω m·ª•c ti√™u (l√° c·ªù)
        function drawGoal() {
            ctx.font = `${TILE_SIZE * 0.8}px 'Segoe UI Emoji', 'Inter', sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const goalX = goal.x * TILE_SIZE + TILE_SIZE / 2;
            const goalY = goal.y * TILE_SIZE + TILE_SIZE / 2;
            ctx.fillText('üö©', goalX, goalY); 
        }

        /**
         * H√†m t√¨m ƒë∆∞·ªùng ƒëi ng·∫Øn nh·∫•t b·∫±ng thu·∫≠t to√°n Breadth-First Search (BFS).
         */
        function findShortestPath(startR, startC, endR, endC) {
            const queue = [{ r: startR, c: startC, path: [{ r: startR, c: startC }] }];
            const visited = new Set();
            visited.add(`${startR},${startC}`);

            while (queue.length > 0) {
                const { r, c, path } = queue.shift();

                if (r === endR && c === endC) {
                    return path; 
                }

                const directions = [
                    { dr: -1, dc: 0 }, { dr: 1, dc: 0 },  
                    { dr: 0, dc: -1 }, { dr: 0, dc: 1 }   
                ];

                for (const dir of directions) {
                    const newR = r + dir.dr;
                    const newC = c + dir.dc;

                    if (newR >= 0 && newR < MAZE_ROWS && newC >= 0 && newC < MAZE_COLS &&
                        maze[newR][newC] === 0 && !visited.has(`${newR},${newC}`)) {
                        visited.add(`${newR},${newC}`);
                        queue.push({ r: newR, c: newC, path: [...path, { r: newR, c: newC }] });
                    }
                }
            }
            return null; 
        }

        /**
         * H√†m v·∫Ω ƒë∆∞·ªùng d·∫´n g·ª£i √Ω tr√™n canvas.
         */
        function drawHintPath(path) {
            if (!path) return;
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)'; /* ƒê∆∞·ªùng vi·ªÅn m√†u v√†ng ƒë·∫≠m */
            ctx.lineWidth = 3;

            ctx.beginPath();
            for (let i = 0; i < path.length; i++) {
                const { r, c } = path[i];
                const centerX = c * TILE_SIZE + TILE_SIZE / 2;
                const centerY = r * TILE_SIZE + TILE_SIZE / 2;

                if (i === 0) {
                    ctx.moveTo(centerX, centerY);
                } else {
                    ctx.lineTo(centerX, centerY);
                }
            }
            ctx.stroke(); 
        }

        // H√†m x·ª≠ l√Ω di chuy·ªÉn ng∆∞·ªùi ch∆°i
        function movePlayer(dx, dy) {
            if (gameWon) return; 
            const nextX = player.x + dx;
            const nextY = player.y + dy;

            if (nextY >= 0 && nextY < MAZE_ROWS && nextX >= 0 && nextX < MAZE_COLS && maze[nextY][nextX] === 0) {
                player.x = nextX;
                player.y = nextY;
                if (showHint) {
                    currentHintPath = findShortestPath(player.y, player.x, goal.y, goal.x);
                }
                drawGame(); 
                checkWin(); 
            }
        }

        // H√†m ki·ªÉm tra chi·∫øn th·∫Øng
        function checkWin() {
            if (player.x === goal.x && player.y === goal.y) {
                gameWon = true;
                messageEl.textContent = 'B·∫°n ƒë√£ th·∫Øng!';
                messageEl.classList.add('animate-bounce'); 
                canvas.style.transform = 'scale(1.02)'; 
                setTimeout(() => {
                    canvas.style.transform = 'scale(1)'; 
                    messageEl.classList.remove('animate-bounce');
                }, 1000);
            }
        }

        // L·∫Øng nghe s·ª± ki·ªán b√†n ph√≠m (cho m√°y t√≠nh ƒë·ªÉ b√†n/m√°y t√≠nh x√°ch tay)
        window.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp': case 'w': movePlayer(0, -1); break;
                case 'ArrowDown': case 's': movePlayer(0, 1); break;
                case 'ArrowLeft': case 'a': movePlayer(-1, 0); break;
                case 'ArrowRight': case 'd': movePlayer(1, 0); break;
            }
        });
        
        // L·∫Øng nghe s·ª± ki·ªán n√∫t "Ch∆°i L·∫°i"
        newGameButton.addEventListener('click', init);

        // L·∫Øng nghe s·ª± ki·ªán n√∫t "H∆∞·ªõng D·∫´n"
        hintButton.addEventListener('click', () => {
            showHint = !showHint; 
            if (showHint) {
                currentHintPath = findShortestPath(player.y, player.x, goal.y, goal.x);
            } else {
                currentHintPath = null;
            }
            drawGame(); 
        });

        // L·∫Øng nghe s·ª± ki·ªán cho c√°c n√∫t ƒëi·ªÅu khi·ªÉn c·∫£m ·ª©ng
        document.getElementById('btn-up').addEventListener('click', () => movePlayer(0, -1));
        document.getElementById('btn-down').addEventListener('click', () => movePlayer(0, 1));
        document.getElementById('btn-left').addEventListener('click', () => movePlayer(-1, 0));
        document.getElementById('btn-right').addEventListener('click', () => movePlayer(1, 0)); 

        // Th√™m s·ª± ki·ªán ch·∫°m v√†o canvas ƒë·ªÉ di chuy·ªÉn nh√¢n v·∫≠t
        canvas.addEventListener('touchend', (e) => {
            if (gameWon) return; 
            const touchX = e.changedTouches[0].clientX - canvas.getBoundingClientRect().left;
            const touchY = e.changedTouches[0].clientY - canvas.getBoundingClientRect().top;

            const playerCanvasX = player.x * TILE_SIZE + TILE_SIZE / 2;
            const playerCanvasY = player.y * TILE_SIZE + TILE_SIZE / 2;

            const deltaX = touchX - playerCanvasX;
            const deltaY = touchY - playerCanvasY;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0) {
                    movePlayer(1, 0); 
                } else {
                    movePlayer(-1, 0); 
                }
            } else {
                if (deltaY > 0) {
                    movePlayer(0, 1); 
                } else {
                    movePlayer(0, -1); 
                }
            }
        });

        // Kh·ªüi ƒë·ªông game khi t·∫£i trang v√† khi c·ª≠a s·ªï thay ƒë·ªïi k√≠ch th∆∞·ªõc
        window.onload = init;
        window.addEventListener('resize', init); 
    </script>
</body>
</html>
