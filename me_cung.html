<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trò Chơi Mê Cung</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            /* Ngăn trình duyệt cuộn trang khi chạm trên mobile */
            touch-action: none;
            /* Ngăn người dùng chọn văn bản */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE10+ */
            user-select: none; /* Standard */
        }
        canvas {
            background-color: #000000; /* Nền canvas màu đen */
            border: 2px solid #4b5563; /* Viền màu xám đậm hơn */
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3); /* Đổ bóng màu đỏ nổi bật hơn */
            transition: transform 0.3s ease-in-out; /* Thêm transition cho canvas */
        }
        /* Kiểu dáng cho các nút điều khiển cảm ứng */
        .touch-controls button {
            width: 65px; /* Kích thước nút lớn hơn cho dễ chạm */
            height: 65px;
            font-size: 28px; /* Kích thước chữ/biểu tượng lớn hơn */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%; /* Làm cho nút tròn */
            transition: background-color 0.2s, transform 0.1s;
        }
        .touch-controls button:active {
            transform: scale(0.95); /* Hiệu ứng nhấn nút */
        }
        /* Kiểu dáng tiêu đề */
        #title {
            font-size: 2.5rem; /* Kích thước chữ đáp ứng cho tiêu đề */
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        /* Điều chỉnh kích thước tiêu đề cho màn hình lớn hơn (ví dụ: máy tính bảng, máy tính để bàn) */
        @media (min-width: 768px) {
            #title {
                font-size: 3.5rem;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-900 to-black flex flex-col items-center justify-center min-h-screen p-4">

    <div class="text-center mb-6">
        <h1 id="title" class="text-red-500 font-extrabold tracking-wide">TRÒ CHƠI MÊ CUNG</h1>
        <p class="text-gray-300 mt-3 text-lg">Sử dụng các phím mũi tên (hoặc các nút bên dưới) để đi đến lá cờ!</p>
    </div>

    <!-- Canvas cho mê cung. max-w-full và h-auto giúp nó đáp ứng với kích thước màn hình. -->
    <canvas id="mazeCanvas" class="max-w-full h-auto"></canvas>

    <!-- Khu vực hiển thị thông báo chiến thắng -->
    <div id="message" class="mt-6 text-3xl font-extrabold text-green-400 h-10 transform transition-transform duration-300 ease-out"></div>
    
    <!-- Nút "Chơi Lại" -->
    <button id="newGameButton" class="mt-8 px-8 py-4 bg-red-600 text-white text-xl font-bold rounded-full shadow-lg hover:bg-red-700 focus:outline-none focus:ring-4 focus:ring-red-500 focus:ring-opacity-75 transition-all transform hover:scale-110 active:scale-95">
        Chơi Lại
    </button>

    <!-- Bảng điều khiển cảm ứng cho di động (chỉ hiển thị trên màn hình nhỏ hơn md) -->
    <div class="touch-controls mt-8 grid grid-cols-3 gap-3 w-60 md:hidden">
        <div></div>
        <button id="btn-up" class="bg-red-500 text-white rounded-full shadow-md active:bg-red-600">↑</button>
        <div></div>
        <button id="btn-left" class="bg-red-500 text-white rounded-full shadow-md active:bg-red-600">←</button>
        <button id="btn-down" class="bg-red-500 text-white rounded-full shadow-md active:bg-red-600">↓</button>
        <button id="btn-right" class="bg-red-500 text-white rounded-full shadow-md active:bg-red-600">→</button>
    </div>

    <script>
        // Lấy các phần tử HTML
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const messageEl = document.getElementById('message');
        const newGameButton = document.getElementById('newGameButton');

        // Cấu hình mê cung
        const TILE_SIZE = 25; // Kích thước cơ bản của mỗi ô
        let MAZE_ROWS; // Số hàng của mê cung
        let MAZE_COLS; // Số cột của mê cung
        let maze = [];

        // Định nghĩa người chơi và mục tiêu
        let player = { x: 1, y: 1, color: '#3b82f6', size: TILE_SIZE * 0.6 }; // Người chơi màu xanh nổi bật
        let goal = {}; // Vị trí mục tiêu
        let gameWon = false; // Trạng thái chiến thắng trò chơi

        /**
         * Hàm tạo mê cung ngẫu nhiên bằng thuật toán Recursive Backtracker (DFS)
         * @param {number} rows - Số hàng của mê cung (phải là số lẻ)
         * @param {number} cols - Số cột của mê cung (phải là số lẻ)
         */
        function generateMaze(rows, cols) {
            let newMaze = Array(rows).fill(null).map(() => Array(cols).fill(1)); // 1 = tường, 0 = đường đi
            const stack = [];
            let current = { r: 1, c: 1 };
            newMaze[current.r][current.c] = 0; // Ô bắt đầu là đường đi
            
            // Tính tổng số ô đường đi cần thiết cho thuật toán tạo mê cung
            const totalPathCells = Math.ceil((rows - 1) / 2) * Math.ceil((cols - 1) / 2);
            let visitedCount = 1;

            while (visitedCount < totalPathCells) {
                const { r, c } = current;
                const neighbors = [];

                // Kiểm tra các ô lân cận chưa được thăm (cách 2 bước, bỏ qua tường)
                if (r > 1 && newMaze[r - 2][c] === 1) neighbors.push({ r: r - 2, c: c, wall: { r: r - 1, c: c } }); // Lên
                if (c < cols - 2 && newMaze[r][c + 2] === 1) neighbors.push({ r: r, c: c + 2, wall: { r: r, c: c + 1 } }); // Phải
                if (r < rows - 2 && newMaze[r + 2][c] === 1) neighbors.push({ r: r + 2, c: c, wall: { r: r + 1, c: c } }); // Xuống
                if (c > 1 && newMaze[r][c - 2] === 1) neighbors.push({ r: r, c: c - 2, wall: { r: r, c: c - 1 } }); // Trái

                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    stack.push(current); // Đẩy ô hiện tại vào stack
                    newMaze[next.wall.r][next.wall.c] = 0; // Đục đường đi qua tường
                    current = { r: next.r, c: next.c }; // Di chuyển đến ô tiếp theo
                    newMaze[current.r][current.c] = 0; // Đánh dấu ô tiếp theo là đường đi
                    visitedCount++;
                } else if (stack.length > 0) {
                    current = stack.pop(); // Quay lui
                } else {
                    // Trường hợp này xử lý khi thuật toán có thể bị kẹt nếu một phần bị cô lập
                    break;
                }
            }

            // Đảm bảo điểm bắt đầu và kết thúc là đường đi
            newMaze[1][1] = 0; // Vị trí người chơi bắt đầu
            newMaze[rows - 2][cols - 2] = 0; // Vị trí mục tiêu

            // Đảm bảo có đường đi đến mục tiêu nếu nó bị tường bao quanh do ngẫu nhiên
            if (newMaze[rows - 3][cols - 2] === 1) newMaze[rows - 3][cols - 2] = 0;
            if (newMaze[rows - 2][cols - 3] === 1) newMaze[rows - 2][cols - 3] = 0;

            return newMaze;
        }

        /**
         * Điều chỉnh kích thước mê cung dựa trên kích thước màn hình hiện tại.
         * Đảm bảo số hàng và cột là số lẻ và có kích thước tối thiểu.
         */
        function setMazeDimensions() {
            // 90% chiều rộng màn hình để có khoảng trống
            const maxCanvasWidth = window.innerWidth * 0.9;
            // 60% chiều cao màn hình để chừa chỗ cho điều khiển
            const maxCanvasHeight = window.innerHeight * 0.6;

            // Tính toán số cột và hàng tối đa có thể vừa, đảm bảo chúng là số lẻ
            MAZE_COLS = Math.floor(maxCanvasWidth / TILE_SIZE);
            MAZE_ROWS = Math.floor(maxCanvasHeight / TILE_SIZE);

            // Đảm bảo số cột và hàng là số lẻ
            MAZE_COLS = MAZE_COLS % 2 === 0 ? MAZE_COLS - 1 : MAZE_COLS;
            MAZE_ROWS = MAZE_ROWS % 2 === 0 ? MAZE_ROWS - 1 : MAZE_ROWS;

            // Đảm bảo kích thước tối thiểu để trò chơi có thể chơi được
            MAZE_COLS = Math.max(15, MAZE_COLS); // Tối thiểu 15 cột
            MAZE_ROWS = Math.max(15, MAZE_ROWS); // Tối thiểu 15 hàng

            // Đảm bảo hàng và cột ít nhất là 3 (1 tường, 1 đường đi, 1 tường)
            MAZE_COLS = MAZE_COLS < 3 ? 3 : MAZE_COLS;
            MAZE_ROWS = MAZE_ROWS < 3 ? 3 : MAZE_ROWS;
            
            // Điều chỉnh lại để đảm bảo chúng là số lẻ (phòng trường hợp min size làm chẵn)
            if (MAZE_COLS % 2 === 0) MAZE_COLS--;
            if (MAZE_ROWS % 2 === 0) MAZE_ROWS--;

            // Fallback cho màn hình rất nhỏ nếu vẫn là số chẵn
            if (MAZE_COLS < 3) MAZE_COLS = 3;
            if (MAZE_ROWS < 3) MAZE_ROWS = 3;

            // Đặt kích thước canvas
            canvas.width = MAZE_COLS * TILE_SIZE;
            canvas.height = MAZE_ROWS * TILE_SIZE;
        }

        // Hàm khởi tạo và vẽ game
        function init() {
            setMazeDimensions(); // Đặt kích thước dựa trên kích thước màn hình hiện tại
            maze = generateMaze(MAZE_ROWS, MAZE_COLS);
            player.x = 1;
            player.y = 1;
            goal.x = MAZE_COLS - 2;
            goal.y = MAZE_ROWS - 2;
            gameWon = false;
            messageEl.textContent = '';
            canvas.style.transform = 'scale(1)'; // Đặt lại tỷ lệ canvas
            drawGame();
        }

        // Hàm vẽ toàn bộ game
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Xóa canvas
            drawMaze(); // Vẽ mê cung
            drawGoal(); // Vẽ mục tiêu
            drawPlayer(); // Vẽ người chơi
        }

        // Hàm vẽ mê cung
        function drawMaze() {
            for (let row = 0; row < MAZE_ROWS; row++) {
                for (let col = 0; col < MAZE_COLS; col++) {
                    if (maze[row][col] === 1) {
                        ctx.fillStyle = '#dc2626'; // Màu tường đỏ
                        ctx.fillRect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        }

        // Hàm vẽ người chơi
        function drawPlayer() {
            const playerX = player.x * TILE_SIZE + TILE_SIZE / 2;
            const playerY = player.y * TILE_SIZE + TILE_SIZE / 2;
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(playerX, playerY, player.size / 2, 0, 2 * Math.PI);
            ctx.fill();
        }

        // Hàm vẽ mục tiêu (lá cờ)
        function drawGoal() {
            // Sử dụng font emoji để hiển thị lá cờ tốt hơn
            ctx.font = `${TILE_SIZE * 0.8}px 'Segoe UI Emoji', 'Inter', sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const goalX = goal.x * TILE_SIZE + TILE_SIZE / 2;
            const goalY = goal.y * TILE_SIZE + TILE_SIZE / 2;
            ctx.fillText('🚩', goalX, goalY);
        }

        // Hàm xử lý di chuyển người chơi
        function movePlayer(dx, dy) {
            if (gameWon) return; // Không di chuyển nếu trò chơi đã thắng
            const nextX = player.x + dx;
            const nextY = player.y + dy;

            // Kiểm tra giới hạn và nếu ô tiếp theo là đường đi (0)
            if (nextY >= 0 && nextY < MAZE_ROWS && nextX >= 0 && nextX < MAZE_COLS && maze[nextY][nextX] === 0) {
                player.x = nextX;
                player.y = nextY;
                drawGame(); // Vẽ lại game sau khi di chuyển
                checkWin(); // Kiểm tra xem người chơi đã thắng chưa
            }
        }

        // Hàm kiểm tra chiến thắng
        function checkWin() {
            if (player.x === goal.x && player.y === goal.y) {
                gameWon = true;
                messageEl.textContent = 'Bạn đã thắng!';
                messageEl.classList.add('animate-bounce'); // Thêm hiệu ứng nảy cho thông báo
                canvas.style.transform = 'scale(1.02)'; // Thu phóng nhẹ canvas khi thắng
                setTimeout(() => {
                    canvas.style.transform = 'scale(1)'; // Đặt lại sau khi animation kết thúc
                    messageEl.classList.remove('animate-bounce');
                }, 1000);
            }
        }

        // Lắng nghe sự kiện bàn phím (cho máy tính để bàn/máy tính xách tay)
        window.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp': case 'w': movePlayer(0, -1); break;
                case 'ArrowDown': case 's': movePlayer(0, 1); break;
                case 'ArrowLeft': case 'a': movePlayer(-1, 0); break;
                case 'ArrowRight': case 'd': movePlayer(1, 0); break;
            }
        });
        
        // Lắng nghe sự kiện nút "Chơi Lại"
        newGameButton.addEventListener('click', init);

        // Lắng nghe sự kiện cho các nút điều khiển cảm ứng
        document.getElementById('btn-up').addEventListener('click', () => movePlayer(0, -1));
        document.getElementById('btn-down').addEventListener('click', () => movePlayer(0, 1));
        document.getElementById('btn-left').addEventListener('click', () => movePlayer(-1, 0));
        document.getElementById('btn-right').addEventListener('click', () => movePlayer(1, 0));

        // Thêm sự kiện chạm vào canvas để di chuyển nhân vật
        canvas.addEventListener('touchend', (e) => {
            if (gameWon) return; // Không xử lý chạm nếu trò chơi đã thắng
            // Lấy vị trí chạm tương đối trên canvas
            const touchX = e.changedTouches[0].clientX - canvas.getBoundingClientRect().left;
            const touchY = e.changedTouches[0].clientY - canvas.getBoundingClientRect().top;

            // Tính toán vị trí trung tâm của người chơi trên canvas
            const playerCanvasX = player.x * TILE_SIZE + TILE_SIZE / 2;
            const playerCanvasY = player.y * TILE_SIZE + TILE_SIZE / 2;

            // Tính toán độ lệch từ vị trí người chơi đến điểm chạm
            const deltaX = touchX - playerCanvasX;
            const deltaY = touchY - playerCanvasY;

            // Xác định hướng di chuyển dựa trên độ lệch lớn nhất
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Di chuyển ngang
                if (deltaX > 0) {
                    movePlayer(1, 0); // Sang phải
                } else {
                    movePlayer(-1, 0); // Sang trái
                }
            } else {
                // Di chuyển dọc
                if (deltaY > 0) {
                    movePlayer(0, 1); // Xuống
                } else {
                    movePlayer(0, -1); // Lên
                }
            }
        });

        // Khởi động game khi tải trang và khi cửa sổ thay đổi kích thước
        window.onload = init;
        window.addEventListener('resize', init); // Khởi tạo lại mê cung khi thay đổi kích thước màn hình để đáp ứng
    </script>
</body>
</html>
